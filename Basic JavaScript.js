// Однорядковий коментар
/* Багатостроковий 
		коментар */
		
// В JavaScript є 9 різних типів даних, а саме: undefined , null , boolean , string , symbol , number, object, bigInt, function

// Оголошення змінної
var myName = 0;

//Оператор привласнення
var a = 7;
var b = a;
var c = "I am a";
/* Коли оголошено змінні JavaScript, вони мають початкове значення undefined. Якщо виконувати математичну операцію з undefined змінною, результат буде NaN, що означає «Not a Number» */

//У JavaScript всі змінні та імена функцій чутливі до регістру
/* Краща практика використовувати camelCase. У camelCase імена змінних з кількома словами мають перше слово в нижньому регістрі, а перша літера кожного наступного слова велика */
var someVariable;
var anotherVariableName;
var thisVariableNameIsSoLong;

//JavaScript використовує символ + як операцію додавання при розміщенні між двома числами
var sum = 10 + 10;

//JavaScript використовує символ - як операцію віднімання при розміщенні між двома числами
var difference = 45 - 33;

//JavaScript використовує символ * як операцію множення при розміщенні між двома числами
var product = 8 * 10;

//JavaScript використовує символ / як операцію ділення при розміщенні між двома числами
var quotient = 66 / 33;

//Збільшення числа
// i++ - еквівалентно виразу i = i + 1
/* Два знаки можна ставити не тільки після змінної, але і перед змінною. Різниця у цьому, що у першому випадку змінна змінюється, але повертається її старе значення, тоді як у другому випадку повертається відразу нове значення. Нижче приклад: */
	// Створюємо змінну зі значенням 1
   var d = 1;
   d++; // Значення 1
   d === 2; // true Тут уже значення 2, тому що це вже наступна операція
    // Створюємо змінну зі значенням 1
   var f = 1;
   ++f; // Значення 2
   f === 2; // Тут у будь-якому разі вже змінена змінна
// Це матиме значення у момент порівняння. Приклад:
     // Створюємо змінну зі значенням 1
   var e = 1;
   e++ === 2; // false, оскільки хоч значення змінної і змінилося, ми отримали її старе значення
     // Створюємо змінну зі значенням 1
   var r = 1;
   ++r === 2; // true, тому що тут ми одразу набули нового значення.

// Ідентично збільшенню числа працює зменшення числа 
var myVar = 11;
myVar--;

//Створення десяткових чисел
var myDecimal = 5.7;

//Множення дробових чисел
var product = 2.0 * 2.5;

//Ділення десяткових чисел
var quotient = 4.4 / 2.0;

//Пошук залишку
//Оператор залишку % дає залишок від поділу двох чисел
var remainder= 11%3;

//Існують оператори, які виконують як математичну операцію, так і призначення за один крок. Одним із таких операторів є оператор +=, -=, *=, /=
//Присвоєння з розширеним додаванням +=
var k = 3;
var p = 17;
var m = 12;
k+=12;
p+=9;
m+=7;

//Присвоєння з розширеним відніманням -=
var z = 11;
var w = 9;
var v = 3;
z-=6;
w-=15;
v-=1;

//Присвоєння з розширеним множенням *=
var aa = 5;
var bb = 12;
var cc = 4.6;
aa*=5;
bb*=3;
cc*=10;

//Присвоєння з розширеним діленням /=
var ff = 48;
var kk = 108;
var rr = 33;
ff/=12;
kk/=4;
rr/=11;

//Оголошення рядкових змінних
var firstName = "Alan";
var lastName = "Turing";

//Екранування лапок у рядках
/*
Коли визначається рядок, оголошення повинне починатися та закінчуватися одинарною або подвійною лапками. Для того, щоб використотувати лапку в середині рядка потрібно екранувати лапку, поміщаючи зворотну косу межу (\) перед нею. Це сигналізує JavaScript, що наступна лапка не є кінцем рядка, а просто частина рядка
*/
var myStr = "I am a \"double quoted\" string inside \"double quotes\".";

//Значення рядків у JavaScript можуть бути записані з одинарними або подвійними лапками, якщо починати і закінчувати одним і тим же типом лапок
const doubleQuoteStr = "Це рядок";
const singleQuoteStr = 'Це також рядок';
//В рядку можна використовувати різні типи кавичок. Приклад:
 const conversation = 'Finn exclaims to Jake, "Algebraic!"';
 var myStr = '<a href="http://www.example.com" target="_blank">Link</a>';

/* Спецсимволи, що екрануються в рядках:
	\'  одиночна цитата
	\"  подвійна цитата
	\\  зворотний слеш
	\n  нова лінія
	\r  повернення каретки
	\t  табуляція
	\b  повернення на одну позицію (backspace)
	\f  форма
*/
var myStr ="FirstLine\n\t\\SecondLine\nThirdLine";

//У JavaScript, коли оператор + використовується з рядком, він називається оператором конкатенації та виконує функцію об'єднання рядків
var myStr = "This is the start. " + "This is the end.";

//Також можна використовувати оператор += для конкатенації рядка в кінець існуючої рядкової змінної. Це може бути дуже корисно для розбиття довгого рядка на кілька рядків
var myStr = "This is the first sentence. ";
myStr += "This is the second sentence.";

// Створення рядка зі змінними
var ourName = "Architect";
var ourStr = "Hello, our name is " + ourName + ", you in the Matrix?";

//Додавання значень змінних до рядків
var someAdjective = "fun";
var myStr = "Learning to code is ";
myStr += someAdjective;

//Знаходження довжини рядка
//Можна знайти довжину рядка, написавши .length після рядкової змінної або рядкового літералу
lastNameLength = lastName.length;

//Використання квадратних дужок для пошуку символів в рядку
//Bracket notation (Скобкова нотація) - це спосіб отримати символ з певним індексом усередині рядка або елемент масиву в масиві
firstLetterOfLastName = lastName[0];
//В JavaScript, відлік починається не з 1, а з 0. Це називається індексацією на основі нуля
//Порядок обчислення індексів починається з нуля, але кількість символів у рядку рахується з одиниці
const str = "one";
str[0] = "o";
str[1] = "n";
str[2] = "e";
str.length === 3;

//Розуміння незмінності рядків
//У JavaScript значення рядків незмінні, а це означає, що вони не можуть бути змінені після створення. Наприклад, наступний код:
var myStr = "Bob";
myStr[0] = "J";
//не може змінити значення myStr на Job, тому що вміст myStr не може бути змінено. Це не означає, що значення змінної myStr не можна змінити. Не можна змінити окремі символи рядка. Але можна змінити в цілому значення змінної myStr, якщо надати їй нове значення, наприклад:
var myStr = "Bob";
myStr = "Job";

//Використання квадратних дужок для пошуку останнього символу у рядку
//Щоб отримати останню літеру рядка, потрібно відняти 1 із довжини цього рядка
var lastLetterOfLastName = lastName[lastName.length - 1];

//Також можна використовувати той же принцип для отримання останнього символу в рядку, щоб отримати певний символ з кінця рядка
var secondToLastLetterOfLastName = lastName[lastName.length - 2];

//Зберігання кількох значень в одній змінній за допомогою масивів (змінні типу Array)
var myArray = ["Hello", 42, "this", "is", "some", "Array"];

//Вкладеність одного масиву в іншому масиві - багатовимірний масив
var myArray = [["multidimensional", "array"], ["how", "awesome"]];

//Доступ до даних масиву, використовуючи індекси
//Ми можемо отримати доступ до даних всередині масивів за допомогою індексів. Індекси масивів пишуться у квадратних дужках так само, як і в рядках. Різниця лише тому, що у рядках через індекси отримуємо символи цих рядків, а масивах отримуємо елементи цих масивів (елементи може бути будь-яких типів, зокрема й іншими масивами). Подібно до рядків, масиви використовують індексування з нульовим індексом, тому першим елементом у масиві є елемент з індексом 0
var array = [50,60,70];
array[0]; // рівно 50
var data = array[1]; // рівно 60 

//Зміна даних масиву за допомогою індексів
//На відміну від рядків, записи масивів змінюються та можуть бути змінені вільно
var ourArray = [50,40,30];
ourArray[0] = 15; // рівно [15, 40, 30]

//Доступ до багатовимірних масивів за допомогою індексів
//Використовуючи дужки для доступу до масиву, перший набір дужок посилається на записи в масиві зовнішнього (першого рівня), а кожна додаткова пара дужок посилається на наступний рівень записів всередині масиву
var arr = [[1,2,3], [4,5,6], [7,8,9], [[10,11,12], 13, 14]]; 
arr[3]; // рівно [[10,11,12], 13, 14]
arr[3][0]; // рівно [10,11,12]
arr[3][0][1]; // рівно 11

//Зміна масивів за допомогою методу Array.prototype.push()
//Простим способом додавання даних до кінця масиву є метод Array.prototype.push()
var arr = [1,2,3];
arr.push(4); // arr тепер [1,2,3,4]
var ourArray = ["Stimpson", "J", "cat"];
ourArray.push(["happy", "joy"]);
// ourArray рівний ["Stimpson", "J", "cat", ["happy", "joy"]]

//Зміна масивів за допомогою методу Array.prototype.pop()
//.pop() використовується для того, щоб "висмикнути" (видалити) останній елемент масиву. Є можливість зберігати це значення "висмикненого" (видаленого) елемента, надавши його змінній
var threeArr = [1, 4, 6];
var oneDown = threeArr.pop();
console.log(oneDown); // Returns 6 
console.log(threeArr); // Returns [1, 4]

//Зміна масивів за допомогою методу Array.prototype.shift()
//.shift працює аналогічним чином, як .pop, але видаляє не останній елемент масиву, а перший
var ourArray = ["Stimpson", "J", ["cat"]];
var removedFromOurArray = ourArray.shift();
// removedFromOurArray now equals "Stimpson" and ourArray now equals ["J", ["cat"]]

//Метод .unshift() працює так само, як .push(), але замість додавання елемента в кінці масиву .unshift() додає елемент на початку масиву
var ourArray = ["Stimpson", "J", "cat"];
ourArray.shift(); // ourArray now equals ["J", "cat"]
ourArray.unshift("Happy");
// ourArray now equals ["Happy", "J", "cat"]

//Створення багаторазово використовуваних функцій
//Функції - багаторазово використовувані блоки
function functionName() {
   console.log ("Hello World");
}
//Викликається або виконується функція, використовуючи її ім'я, за якою слідують дужки
functionName();
//Щоразу, коли функція викликається, виконується прописаний у ній код (всередині фігурних дужок)

//Передача значень функції з аргументами
//Параметри (або аргументи) – це змінні, які діють як заповнювачі для значень, які мають бути введені у функцію під час її виклику
//Фактичні значення, які вводяться (або «передані») у функцію під час її виклику, називаються аргументами. Ось функція з двома аргументами param1 та param2 :
function testFun(param1, param2) {
   console.log(param1, param2);
}
//Потім ми можемо викликати функцію testFun з передачею до неї аргументів:
testFun("Hello", "World");
//Ми передали два аргументи: "Hello" та "World". Усередині функції param1 дорівнюватиме "Hello", а param2 дорівнюватиме "World". Зверніть увагу, що ви можете знову викликати testFun з іншими аргументами і параметри будуть приймати значення нових аргументів
function functionWithArgs (a, b) {
console.log(a + b)
}
functionWithArgs (1,2); //output 3
functionWithArgs (7,9); // output 16

//Глобальна область видимості та функції
//Змінні, визначені поза функціональним блоком, мають глобальну область. Це означає, що їх можна побачити всюди у JavaScript-коді. Змінні, які використовуються без ключового слова var, автоматично створюються у глобальній області видимості. Завжди потрібно оголошувати змінні за допомогою var, let чи const залежно від ситуації

//Змінні, оголошені всередині функції та параметри функції мають локальну область видимості. Це означає, що вони помітні лише всередині цієї функції. Ось функція myTest з локальною змінною loc:
function myTest () {
  var loc = "foo";
  console.log(loc);
}
myTest (); // logs "foo"
console.log(loc); // Error: loc не визначений

//Глобальна та локальна область видимості у функціях
//Можна мати як локальні, і глобальні змінні з тим самим ім'ям. Локальна змінна має пріоритет над глобальною змінною. У цьому прикладі:
var someVar = "Hat";
function myFun() {
   var someVar = "Head";
   return someVar;
}
myFun(); // Head
//функція myFun поверне "Head" тому що є локальна версія змінної

//Передача значення у функцію з аргументами. Для цього можна використовувати оператор return, щоб повернути результат виконання функції
function timesFive (num) {
  return num * 5;
}
console.log(timesFive(5)); // should return 25
console.log(timesFive(2)); // should return 10
console.log(timesFive(0)); // should return 0

//Розуміння невизначеного значення, що повертається функцією
//Функція може включати оператор return, але це не обов'язково. У випадку, якщо функція не має оператора return, коли вона викликається, функція обробляє внутрішній код, але значення, що повертається, є undefined (тобто не визначено)
var sum = 0;
   function addSum(num) {
     sum = sum + num;
   }
   var receivedValue = addSum(3); // сума буде змінена, але значення, що повертається, не визначено

//Черги
//У інформатиці черга являє собою абстрактну структуру даних, у якій елементи зберігаються у порядку. Нові елементи можуть бути додані до кінця черги, а старі елементи витягуються з початку черги.
// Завдання. Напишіть функцію nextInLine, яка приймає масив arr та число item як аргументи. Додайте число item до кінця масиву, потім видаліть перший елемент масиву. Потім функція nextInLine повинна повернути видалений елемент.
function nextInLine(arr, item) {
	arr.push(item);
  return arr.shift();
}
var testArr = [1,2,3,4,5];
console.log("Before: " + JSON.stringify(testArr));
console.log(nextInLine(testArr, 6));
console.log("After: " + JSON.stringify(testArr));

